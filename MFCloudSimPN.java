/*
 * Title:        CloudSim Toolkit
 * Description:  CloudSim (Cloud Simulation) Toolkit for Modeling and Simulation
 *               of Clouds
 * Licence:      GPL - http://www.gnu.org/copyleft/gpl.html
 *
 * Copyright (c) 2009, The University of Melbourne, Australia
 */



import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.LinkedList;
import java.util.List;
import java.util.Random;

import org.cloudbus.cloudsim.Cloudlet;
import org.cloudbus.cloudsim.CloudletSchedulerTimeShared;
import org.cloudbus.cloudsim.Datacenter;
import org.cloudbus.cloudsim.DatacenterBroker;
import org.cloudbus.cloudsim.DatacenterCharacteristics;
import org.cloudbus.cloudsim.Host;
import org.cloudbus.cloudsim.Log;
import org.cloudbus.cloudsim.Pe;
import org.cloudbus.cloudsim.Storage;
import org.cloudbus.cloudsim.UtilizationModel;
import org.cloudbus.cloudsim.UtilizationModelFull;
import org.cloudbus.cloudsim.Vm;
import org.cloudbus.cloudsim.VmAllocationPolicySimple;
import org.cloudbus.cloudsim.VmSchedulerTimeShared;
import org.cloudbus.cloudsim.core.CloudSim;
import org.cloudbus.cloudsim.core.SimEntity;
import org.cloudbus.cloudsim.core.SimEvent;
import org.cloudbus.cloudsim.core.predicates.Predicate;
import org.cloudbus.cloudsim.provisioners.BwProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.PeProvisionerSimple;
import org.cloudbus.cloudsim.provisioners.RamProvisionerSimple;

/**
 * An example showing how to create simulation entities
 * (a DatacenterBroker in this example) in run-time using
 * a globar manager entity (GlobalBroker).
 */
public class MFCloudSimPN {
	/* Model parameters: all model parameters have been collected here */
	
		// Data center parameters
		final static int NrDatacenters = 1;				// Number of data centers
		final static int NrQuadCoreServerPerDC = 1;		// Quad core servers in each DC
		final static int NrDualCoreServerPerDC = 1;		// Duel core servers in each DC
		final static int ServersSpeed = 1000;			// Speed of each core of a server
		
		// Workload parameters
		final static long AverageLength = 40000;		// Average length of cloudlet
		final static int VMSpeed = 250; 				// Speed of the VM
		final static int NCloudlets = 10;				// Number of cloudlet generated by a new broker
		final static int NVMs = 5;						// Number of VMs created by a broker to support a new job

		// Petri Nets parameters
		final static int N_marking_Par = 5;				// Parameter N of the PN (system users)
		final static int M_marking_Par = 3;				// Parameter M of the PN (maximum usesr simultaneously in the cloud)
		final static double T0_FiringTime = 50.0;		// Firing time of T0 : average time to analyse a return from the system
		final static double T1_FiringTime = 100.0;		// Firing time of T1 : average time for a submission to the system
		final static double T5_FiringTime = 200.0;		// Firing time of T5 : average time for a local processing
		final static double T2_weight = 0.7;			// Weight of T2 : probability of local processing
		final static double T3_weight = 0.3;			// Weight of T3 : probability of sending to the cloud

		// Global simulation parameters
		final static double transientEnd = 10000.0;			// End of transient
		final static double collectionEnd = 110000.0;			// End of data collection
		final static double simEnd = 120000.0;			// End of simulation
	
    static Random randomobject = new Random();

	private static List<Vm> createVM(int userId, int vms, int idShift) {
		//Creates a container to store VMs. This list is passed to the broker later
		LinkedList<Vm> list = new LinkedList<Vm>();

		//VM Parameters
		long size = 10000; //image size (MB)
		int ram = 512; //vm memory (MB)
		int mips = VMSpeed;
		long bw = 1000;
		int pesNumber = 1; //number of cpus
		String vmm = "Xen"; //VMM name

		//create VMs
		Vm[] vm = new Vm[vms];

		for(int i=0;i<vms;i++){
			vm[i] = new Vm(idShift + i, userId, mips, pesNumber, ram, bw, size, vmm, new CloudletSchedulerTimeShared());
			list.add(vm[i]);
		}

		return list;
	}


	private static List<Cloudlet> createCloudlet(int userId, int cloudlets, int idShift){
		// Creates a container to store Cloudlets
		LinkedList<Cloudlet> list = new LinkedList<Cloudlet>();

		//cloudlet parameters
		long length = AverageLength;
		long fileSize = 300;
		long outputSize = 300;
		int pesNumber = 1;
		UtilizationModel utilizationModel = new UtilizationModelFull();

		Cloudlet[] cloudlet = new Cloudlet[cloudlets];

		for(int i=0;i<cloudlets;i++){
			cloudlet[i] = new Cloudlet(idShift + i, Math.round(-length * Math.log(randomobject.nextDouble())), pesNumber, fileSize, outputSize, utilizationModel, utilizationModel, utilizationModel);	// random exponential loads
//			cloudlet[i] = new Cloudlet(idShift + i, length, pesNumber, fileSize, outputSize, utilizationModel, utilizationModel, utilizationModel);					// deterministic load
			// setting the owner of these Cloudlets
			cloudlet[i].setUserId(userId);
			list.add(cloudlet[i]);
		}

		return list;
	}


	////////////////////////// STATIC METHODS ///////////////////////

	/**
	 * Creates main() to run this example
	 */
	public static void main(String[] args) {
		try {
			// First step: Initialize the CloudSim package. It should be called
			// before creating any entities.
			int num_user = 2;   // number of grid users
			Calendar calendar = Calendar.getInstance();
			boolean trace_flag = false;  // mean trace events

Log.disable();

			// Initialize the CloudSim library
			CloudSim.init(num_user, calendar, trace_flag);

			// the GlobalBroker actuall contains all the simulation model
			GlobalBroker globalBroker = new GlobalBroker("GlobalBroker");

			// Second step: Create Datacenters
			//Datacenters are the resource providers in CloudSim. We need at list one of them to run a CloudSim simulation
			Datacenter[] datacenters = new Datacenter[NrDatacenters];
			for(int i = 0; i < NrDatacenters; i++) {
				datacenters[i] = createDatacenter("Datacenter_"+i);
			}


			CloudSim.startSimulation();

			List<? extends DatacenterBroker> brokerList = globalBroker.getBrokerList();
			List<Cloudlet> newList = new ArrayList<Cloudlet>();
			
			for(int i = 0; i < brokerList.size(); i++) {
				newList.addAll(brokerList.get(i).getCloudletReceivedList());
			}

			CloudSim.stopSimulation();
Log.enable();
			Log.printLine("#### CloudletData ####");
			printCloudletList(newList);
			Log.printLine("#### TransitionsData ####");
			printPNevolution(globalBroker.getFiringCount());
			Log.printLine("#### PlacesData ####");
			printPNevolution(globalBroker.getPNevolution());
		}
		catch (Exception e)
		{
			e.printStackTrace();
			Log.printLine("The simulation has been terminated due to an unexpected error");
		}
	}
	
	private static void printPNevolution(List<PNevolution> pev){
		double pT = 0.0;
		for(int i = 0; i < pev.size(); i++) {
			PNevolution pe = pev.get(i);
			int[] pm = pe.getP();
			double delta = (i < pev.size()-1) ? pev.get(i+1).getT()-pe.getT() : 0.0;
			String out = "";
			for(int j = 0; j < pm.length; j++) {
				out = out+" "+pm[j];
			}
			Log.printLine(pe.getT()+" "+delta+out);
			pT = pe.getT();
		}
	}

	private static Datacenter createDatacenter(String name){

		// Here are the steps needed to create a PowerDatacenter:
		// 1. We need to create a list to store one or more
		//    Machines
		List<Host> hostList = new ArrayList<Host>();

		// 2. A Machine contains one or more PEs or CPUs/Cores. Therefore, should
		//    create a list to store these PEs before creating
		//    a Machine.
		List<Pe> peList1 = new ArrayList<Pe>();

		int mips = ServersSpeed;

		// 3. Create PEs and add these into the list.
		//for a quad-core machine, a list of 4 PEs is required:
		peList1.add(new Pe(0, new PeProvisionerSimple(mips))); // need to store Pe id and MIPS Rating
		peList1.add(new Pe(1, new PeProvisionerSimple(mips)));
		peList1.add(new Pe(2, new PeProvisionerSimple(mips)));
		peList1.add(new Pe(3, new PeProvisionerSimple(mips)));

		//Another list, for a dual-core machine
		List<Pe> peList2 = new ArrayList<Pe>();

		peList2.add(new Pe(0, new PeProvisionerSimple(mips)));
		peList2.add(new Pe(1, new PeProvisionerSimple(mips)));

		//4. Create Hosts with its id and list of PEs and add them to the list of machines
		int hostId=0;
		int ram = 16384; //host memory (MB)
		long storage = 1000000; //host storage
		int bw = 10000;

		for(int i = 0; i < NrQuadCoreServerPerDC; i++) {
			hostList.add(
	    			new Host(
	    				hostId,
	    				new RamProvisionerSimple(ram),
	    				new BwProvisionerSimple(bw),
	    				storage,
	    				peList1,
	    				new VmSchedulerTimeShared(peList1)
	    			)
	    		); // This are quad core machines
	
			hostId++;
		}
		
		for(int i = 0; i < NrDualCoreServerPerDC; i++) {
			hostList.add(
    			new Host(
    				hostId,
    				new RamProvisionerSimple(ram),
    				new BwProvisionerSimple(bw),
    				storage,
    				peList2,
    				new VmSchedulerTimeShared(peList2)
    			)
    		); // Dual core machines
			hostId++;
		}
		// 5. Create a DatacenterCharacteristics object that stores the
		//    properties of a data center: architecture, OS, list of
		//    Machines, allocation policy: time- or space-shared, time zone
		//    and its price (G$/Pe time unit).
		String arch = "x86";      // system architecture
		String os = "Linux";          // operating system
		String vmm = "Xen";
		double time_zone = 10.0;         // time zone this resource located
		double cost = 3.0;              // the cost of using processing in this resource
		double costPerMem = 0.05;		// the cost of using memory in this resource
		double costPerStorage = 0.1;	// the cost of using storage in this resource
		double costPerBw = 0.1;			// the cost of using bw in this resource
		LinkedList<Storage> storageList = new LinkedList<Storage>();	//we are not adding SAN devices by now

		DatacenterCharacteristics characteristics = new DatacenterCharacteristics(
                arch, os, vmm, hostList, time_zone, cost, costPerMem, costPerStorage, costPerBw);


		// 6. Finally, we need to create a PowerDatacenter object.
		Datacenter datacenter = null;
		try {
			datacenter = new Datacenter(name, characteristics, new VmAllocationPolicySimple(hostList), storageList, 0);
		} catch (Exception e) {
			e.printStackTrace();
		}

		return datacenter;
	}


	/**
	 * Prints the Cloudlet objects
	 * @param list  list of Cloudlets
	 */
	private static void printCloudletList(List<Cloudlet> list) {
		int size = list.size();
		Cloudlet cloudlet;

		String indent = "    ";
//		Log.printLine();
//		Log.printLine("========== OUTPUT ==========");
//		Log.printLine("Cloudlet ID" + indent + "STATUS" + indent +
//				"Data center ID" + indent + "VM ID" + indent + indent + "Time" + indent + "Start Time" + indent + "Finish Time");
//
		DecimalFormat dft = new DecimalFormat("###.##");
		for (int i = 0; i < size; i++) {
			cloudlet = list.get(i);
			Log.print(indent + cloudlet.getCloudletId() + indent + indent);

			if (cloudlet.getCloudletStatus() == Cloudlet.SUCCESS){
				Log.print("SUCCESS");

				Log.printLine( indent + indent + cloudlet.getResourceId() + indent + indent + indent + cloudlet.getVmId() +
						indent + indent + indent + dft.format(cloudlet.getActualCPUTime()) +
						indent + indent + dft.format(cloudlet.getExecStartTime())+ indent + indent + indent + dft.format(cloudlet.getFinishTime()));
			}
		}

	}
	
	public static class PNevolution {
		double T;
		int[] P;
		public PNevolution(double _T, int[] _P) {T=_T; P=_P.clone();}
		public double getT() {return T;}
		public int[] getP() {return P;}
	}
	

	public static class GlobalBroker extends SimEntity {
		//
		// PETRI NET MODEL DEFINITION
		//
		final static int 	 P0[]  = {N_marking_Par,0,0,0,0,M_marking_Par,0};	// initial marking
		final static double  Trp[] = {T0_FiringTime, T1_FiringTime, T2_weight, T2_weight, 1, T5_FiringTime, 1};	// transition rates
		final static boolean Imm[] = {false, false, true, true, true, false, true};
		
		int 	P[] = new int[9+NrQuadCoreServerPerDC+NrDualCoreServerPerDC];
		boolean T[] = {false, false, false, false, false, false, false}; // current transition enabling state
		final static int totTrans = 7;	// total number of transitions
		int FiringCount[] = new int[totTrans+NrQuadCoreServerPerDC+NrDualCoreServerPerDC+2];
		
		int runningBrokers;
		int endedBrokers;
		
		int runningCloudlet;
		int endedCloudlet;

		// abilitation of transitions
		boolean[] findEnabledTransitions() {
			boolean ed[] = new boolean[totTrans];
			
			// T0
			ed[0] = (P[6] > 0);

			// T1
			ed[1] = (P[0] > 0);
			
			// T2
			ed[2] = (P[1] > 0);

			// T3
			ed[3] = (P[1] > 0);

			// T4
			ed[4] = (P[3] > 0) && (P[5] > 0);

			// T5
			ed[5] = (P[2] > 0);

			// T6
			ed[6] = (P[4] > 0);


			return ed;
		}
		
		// firing of transitions
		boolean fireTransition(int t) {
			boolean startBroker = false;
			FiringCount[t]++;
			
			switch(t) {
			  case 0:
			  	P[6]--;
			  	P[0]++;
				break;
			  case 1:
			  	P[0]--;
			  	P[1]++;
				break;
			  case 2:
			  	P[1]--;
			  	P[2]++;
				break;
			  case 3:
			  	P[1]--;
			  	P[3]++;
				break;
			  case 4:
//Log.printLine("Firing T4");
			  	P[3]--;
			  	P[5]--;
				startBroker = true;
//				P[4]++;	// Temporary to test the PN
				break;
			  case 5:
			  	P[2]--;
			  	P[6]++;
				break;
			  case 6:
			  	P[4]--;
			  	P[5]++;
			  	P[6]++;
				break;
			}
			
			return startBroker;

		}
		
		class MatchTransition extends Predicate {
			int Tid;
			public MatchTransition(int j) {Tid = j;}
			@Override
			public boolean match(SimEvent event) {
				return((event.getType() == SIMULATION_EVENT) && (0 == Tid));
			}
		}
		
		boolean checkAndSchedulePN(boolean enabled[]) {
			boolean startBroker = false;
			
			boolean isVanishing = false;
			double vRate = 0.0;
			for(int i = 1; i < totTrans; i++) {
				if(Imm[i] && enabled[i]) {
					isVanishing = true;
					vRate += Trp[i];
				}
			}

//Log.printLine("Van: "+isVanishing);
			if(!isVanishing) {
			  for(int i = 0; i < totTrans; i++) {
//Log.printLine("T"+i+" "+enabled[i]+" "+Imm[i]+" "+T[i]);
				if(!Imm[i]) {	// if it is not immediate, 
				  if(enabled[i] && (!T[i])) {	// a transition become enabled
						double firingTime = -Trp[i] * Math.log(randomobject.nextDouble());
//Log.printLine("Scheduling T"+i+" at "+firingTime);
						schedule(getId(), firingTime,
							     SIMULATION_EVENT, new EventData(i));
						T[i] = true;
				  } else if((!enabled[i]) && T[i]) {	// a previously enabled transition become inactive
//Log.printLine("Deleting firing of T"+i);
					cancelEvent(new MatchTransition(i));
					T[i] = false;
				  }
				}
			  }
			} else {			// For vanishing markings
			  double r = randomobject.nextDouble() * vRate;
//Log.printLine("R: "+r+" : "+vRate);
			  for(int i = 0; i < totTrans; i++) {
				if(Imm[i] && enabled[i]) {	// if it is immediate,
//Log.printLine("T"+i+" ("+Imm[i]+") r "+r+" < "+Trp[i]);
				  if(r < Trp[i]) {
//Log.printLine("Vanishing fire P: " + P[0] + " " + P[1] + " " + P[2] + " " + P[3] + " " + P[4] + " " + P[5] + " " + P[6]);
					startBroker = fireTransition(i);
//Log.printLine(" T" + i + " P: " + P[0] + " " + P[1] + " " + P[2] + " " + P[3] + " " + P[4] + " " + P[5] + " " + P[6]);
					startBroker |= checkAndSchedulePN(findEnabledTransitions());
				    break;
				  } else {
				  	r -= Trp[i];
				  }
				}
			  }
			}
			return startBroker;
		}
		
		
		private static class EventData {
			int transitionId;
			
			public EventData(int id) {transitionId = id;}
			int getId() {return transitionId;}
		}

		public static class InterceptEndDatacenterBroker extends DatacenterBroker {
			int evId;
			SimEntity uS;
			public InterceptEndDatacenterBroker(String name, int eId, SimEntity s) throws Exception {
				super(name);
				evId = eId;
				uS = s;
			}
	
			@Override
			public void submitCloudlets()
			{
				super.submitCloudlets();
				uS.scheduleNow(evId, CLOUDLET_START, getCloudletSubmittedList());
//
//				List<Cloudlet> cl = getCloudletSubmittedList();
//				Log.printLine("Clouded found: " + cl.size());
//				for(int i = 0; i < cl.size(); i++) {
//					Log.printLine(i + " -> " + cl.get(i).getVmId());
//				}
			}
			
			@Override
			public void shutdownEntity()
			{
				super.shutdownEntity();
				uS.scheduleNow(evId, BROKER_SHUTDOWN);
			}
			
			@Override
			protected void processCloudletReturn(SimEvent ev) {
				super.processCloudletReturn(ev);
				uS.scheduleNow(evId, CLOUDLET_END, ev.getData());
			}
		}
		
		private static InterceptEndDatacenterBroker createInterceptEndBroker(String name, int i, SimEntity s){
	
			InterceptEndDatacenterBroker broker = null;
			try {
				broker = new InterceptEndDatacenterBroker(name, i, s);
			} catch (Exception e) {
				e.printStackTrace();
				return null;
			}
			return broker;
		}

		private static final int SIMULATION_EVENT = 0;
		private static final int BROKER_SHUTDOWN = 1;
		private static final int CLOUDLET_END = 2;
		private static final int CLOUDLET_START = 3;
		private static final int TRANSIENT_END = 4;
		private static final int COLLECTION_END = 5;
		private static final int SIM_END = 6;
		private List<Vm> vmList;
		private List<Vm> allVmList = new ArrayList<Vm>();
		private List<Cloudlet> cloudletList;
		int NVM = 0;
		int NCloudlet = 0;
		int NBroker = 0;

		private List<InterceptEndDatacenterBroker> brokerList = new ArrayList<InterceptEndDatacenterBroker>();
		private List<PNevolution> pnEvol = new ArrayList<PNevolution>();
		private List<PNevolution> trEvol = new ArrayList<PNevolution>();


		public GlobalBroker(String name) {
			super(name);
		}

		boolean quitting = false;
		
		void startNewBroker() {
			InterceptEndDatacenterBroker broker = createInterceptEndBroker(super.getName()+"_"+NBroker, getId(), this);
			NBroker++;
			brokerList.add(broker);

			//Create VMs and Cloudlets and send them to broker
			setVmList(createVM(broker.getId(), NVMs, NVM)); //creating 5 vms
			setCloudletList(createCloudlet(broker.getId(), NCloudlets, NCloudlet)); // creating 10 cloudlets
			NVM += NVMs;
			NCloudlet += NCloudlets;

			broker.submitVmList(getVmList());
			broker.submitCloudletList(getCloudletList());
			
			runningBrokers++;
			P[7] = runningBrokers;
			
			runningCloudlet += NCloudlets;
			P[8] = runningCloudlet;
		}

		@Override
		public void processEvent(SimEvent ev) {
			int hid;
			switch (ev.getTag()) {
			case SIMULATION_EVENT:
				if(!quitting) {
					int Tid = ((EventData)(ev.getData())).getId();
//Log.printLine(ev.eventTime() + " P: " + P[0] + " " + P[1] + " " + P[2] + " " + P[3] + " " + P[4] + " " + P[5] + " " + P[6]);
					boolean startBroker = fireTransition(Tid);
					T[Tid] = false;		// Disable so that it can fire again
					startBroker |= checkAndSchedulePN(findEnabledTransitions());
Log.printLine(ev.eventTime() + " T" + Tid + " P " + P[0] + " " + P[1] + " " + P[2] + " " + P[3] + " " + P[4] + " " + P[5] + " " + P[6] + " St.Br " + startBroker);
					
					if(startBroker) {
Log.printLine(ev.eventTime() + " Starting Broker!");
						startNewBroker();
					}
					pnEvol.add(new PNevolution(ev.eventTime(), P));
				}
				CloudSim.resumeSimulation();

				break;

			case BROKER_SHUTDOWN:
				Log.printLine(ev.eventTime() + " > " + getName() + ": BROKER_SHUTDOWN");
				runningBrokers--;
				P[7] = runningBrokers;
				endedBrokers++;

				P[4]++;		/////// VERY CASE STUDY SPECIFIC: ADDS A TOKE IN P4
				if(checkAndSchedulePN(findEnabledTransitions())) {
Log.printLine(ev.eventTime() + " Starting Broker!");
//Log.printLine("\n\n\n\n CHAIN START \n\n\n\n\n");
					startNewBroker();
				}
				pnEvol.add(new PNevolution(ev.eventTime(), P));
				break;
			case CLOUDLET_END:
				runningCloudlet--;
				P[8] = runningCloudlet;
				endedCloudlet++;
				
				Cloudlet clt = (Cloudlet)(ev.getData());
				Log.printLine(ev.eventTime() + " Cloudlet End " + clt.getCloudletId());
//				Log.printLine("Was on Host " + allVmList.get(clt.getVmId()).getHost().getId());
				hid = allVmList.get(clt.getVmId()).getHost().getId();
				P[9 + hid]--;
				FiringCount[9 + hid]++;
				pnEvol.add(new PNevolution(ev.eventTime(), P));
				break;
			case CLOUDLET_START:
				List<Cloudlet> Lc = (List<Cloudlet>)(ev.getData());
				Log.printLine(ev.eventTime() + " Cloudlet START " + Lc.size());
				for(int i = 0; i < Lc.size(); i++) {
//					Log.printLine(i + " -> " + allVmList.get(Lc.get(i).getVmId()).getHost().getId());
					hid = allVmList.get(Lc.get(i).getVmId()).getHost().getId();
					P[9 + hid]++;
				}
				pnEvol.add(new PNevolution(ev.eventTime(), P));
				break;
			case TRANSIENT_END:
				FiringCount[totTrans] = endedBrokers;
				FiringCount[totTrans+1] = endedCloudlet;
				trEvol.add(new PNevolution(ev.eventTime(), FiringCount));
				Log.printLine(ev.eventTime() + " End of transient");
				break;
			case COLLECTION_END:
				FiringCount[totTrans] = endedBrokers;
				FiringCount[totTrans+1] = endedCloudlet;
				trEvol.add(new PNevolution(ev.eventTime(), FiringCount));
				Log.printLine(ev.eventTime() + " End of collection");
				break;
			case SIM_END:
				FiringCount[totTrans] = endedBrokers;
				FiringCount[totTrans+1] = endedCloudlet;
				trEvol.add(new PNevolution(ev.eventTime(), FiringCount));
				Log.printLine(ev.eventTime() + " End of simulation");
				quitting = true;
				break;
			default:
				Log.printLine(getName() + ": unknown event type");
				break;
			}
		}

		@Override
		public void startEntity() {
			Log.printLine(super.getName()+" is starting...");
			for(int i=0;i<7;i++) {
				P[i]=P0[i];
			}
			for(int i=P0.length;i<P.length;i++) {
				P[i]=0;
			}

			schedule(getId(), transientEnd, TRANSIENT_END);
			schedule(getId(), collectionEnd, COLLECTION_END);
			schedule(getId(), simEnd, SIM_END);
			checkAndSchedulePN(findEnabledTransitions());
			pnEvol.add(new PNevolution(0.0, P));
		}

		@Override
		public void shutdownEntity() {
		}

		public List<Vm> getVmList() {
			return vmList;
		}

		protected void setVmList(List<Vm> vmList) {
			this.allVmList.addAll(vmList);
			this.vmList = vmList;
		}

		public List<Cloudlet> getCloudletList() {
			return cloudletList;
		}

		protected void setCloudletList(List<Cloudlet> cloudletList) {
			this.cloudletList = cloudletList;
		}

		public List<InterceptEndDatacenterBroker> getBrokerList() {
			return brokerList;
		}
		
		public List<PNevolution> getFiringCount() {
			return trEvol;
		}
		public List<PNevolution> getPNevolution() {
			return pnEvol;
		}
	}

}
